## lift
> "lifts" a function of arity >= 1 so that it may "map over" a list, Function or other object that satisfies the FantasyLand Apply spec.

## 설명
- 배열을 여러 개 받고, 받은 배열의 순서대로 두 배열을 카르테시안 곱으로 미리 정한 연산을 수행하고 그 결과를 그 다음 배열과도 카르테시안 곱으로 연산을 수행한다.
- 첫 번째 배열의 첫 번째 원소를 선택하고 두 번째 배열의 모든 원소를 매칭시키고 이 각각의 매칭에 대해 세 번째 배열의 모든 원소를 매칭시킨다. 이런 식으로 다음 배열도 매칭을 시킨다. 그러면 첫 번째 배열의 첫 번째 원소와 2번째, 3번째, 4번째 배열의 원소를 매칭시키면서 많은 매칭 세트가 나온다. 이를 미리 정의한 함수의 인자로 차례로 할당하여 함수의 결과 값을 얻는다. 여러개의 매칭 세트를 함수에 할당하므로 여러 결과가 나온다. 이를 배열로 나열한다.
- 첫 번째 배열의 첫 번재 원소뿐만 아니라 두 번째 원소도 마찬가지로 매칭 세트를 형성하고 이를 미리 정의한 함수의 인자로 차례로 할당하여 함수의 결과 값을 얻는다. 여러개의 매칭 세트를 함수에 할당하므로 여러 결과가 나온다. 이를 배열로 나열한다.
- 이런 식으로 모든 원소에 대해서 매칭 세트를 형성하고 이 매칭 세트를 미리 정의한 함수의 인자로 할당하여 함수의 결과값을 얻어 배열로 나열한다.

## 표현
```
(*… → *) → ([*]… → [*])
```
- `(*… → *)` 첫 번째 인자로는 인자를 여러 개 받아 하나의 값으로 만드는 함수를 받는다. 이 함수는 두 번째 인자로 할당되는 함수의 인자로 할당되는 배열들이 카르테시안 곱으로 이루는 각 배열당 하나의 원소를 갖는 조합세트의 원소들을 할당하여 결과값을 구하기 위한 함수이다.
- `→ ([*]… → [*])`부분은 `[*]...` 그 결과 인자로 배열을 여러 개 받아서 하나의 배열로 만드는 함수가 반환된다.

## 설명
```
const madd3 = R.lift((a, b, c) => a + b + c);

madd3([100, 200], [30, 40], [5, 6, 7]); //=> [135, 136, 137, 145, 146, 147, 235, 236, 237, 245, 246, 247]

const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);

madd5([10, 20], [1], [2, 3], [4], [100, 200]); //=> [117, 217, 118, 218, 127, 227, 128, 228]
```
- `[100, 200], [30, 40], [5, 6, 7]` 부분을 보면 계산의 전개 과정은 하나의 배열의 임의의 원소와 다른 배열의 임의의 원소를 1대1로 매칭시켜서 덧셈을 수행하도록 한다. 따로 떼어 보면 `[100, 200], [30, 40]`의 경우 `[100+30, 100+40, 200+30, 200+40]`가 되며 `[100+30, 100+40, 200+30, 200+40]`과 `[5, 6, 7]`를 보면 `[100+30+5, 100+30+6, 100+30+7, 100+40+5,  100+40+6, 100+40+7, 200+30+5, 200+30+6, 200+30+7, 200+40+5, 200+40+6, 200+40+7]`으로 전개 되는 구조를 가지고 있다.
- `R.lift((a, b, c) => a + b + c)` lift 함수를 세 원소의 덧셈으로 정의를 했기 때문에 세 개의 배열을 받아서 세 배열의 카르테시안 곱으로 만든 조합의 각 원소를 하나씩 lift 함수에 정의한 함수에 넣어 결과 값을 나열한 배열을 반환한다.
- `R.lift((a, b, c, d, e) => a + b + c + d + e)`는 4개의 인자를 가지므로 배열을 카르테시안 곱으로 4개의 원소 조합을 갖도록 만들기 위해서는 4개의 배열을 받아야 한다. 위와 동일한 원리이므로 설명은 생략한다.

## Reference
- https://ramdajs.com/docs/#lift

## chain
> chain maps a function over a list and concatenates the results. chain is also known as flatMap in some libraries.
- 체인은 리스트가 가진 원소 각각에 대해 동일한 하나의 함수를 매핑하고 반환된 각각의 배열의 중첩을 제거한 결과를 반환한다. 일부 라이브러리에서는 `flatMap`으로 알려져 있다.
> Dispatches to the chain method of the second argument, if present, according to the FantasyLand Chain spec.
- 만약 두 번째 인자가 존재한다면 `FantasyLand`의 체인 사양에 맞게 체인메소드의 두 번째 인자에 대상(리스트 또는 함수)을 전달한다.
> If second argument is a function, chain(f, g)(x) is equivalent to f(g(x), x).
- 두 번째 인자가 함수인 경우에는 `chain(f, g)(x)`는 `f(g(x), x)`와 동등하다.
> Acts as a transducer if a transformer is given in list position.

## 설명
- 첫 번째 인자로 하나의 인자를 받아서 리스트 또는 함수를 반환하는 함수를 받는다. 
- 두 번째 인자로 리스트 또는 함수를 받는다.
- 두 번째 인자로 리스트를 받을 경우 `map` 함수를 을 적용하고 그 결과에 `flatten` 함수를 적용하는 것과 동일한 역할을 한다.
- 두 번째 인자로 함수를 받을 경우 첫 번째 인자를 `f`, 두 번째 인자를 `g`, 두 인자를 할당하여 반환되는 함수가 갖는 인자를 x라고 했을 때 `f(g(x), x)` 연산을 수행한다.
- `chain`이란 함수를 만든 것은 입력과 출력의 형태를 모나드화하여 함수 연산을 체이닝 할 수 있는 형태로 계속 유지하겠다는 의미를 가지고 있다. 이때 입력이란 두 번째 인자에 할당된 값이며 출력이란 `chain` 함수가 평가되어 반환되는 결과를 의미한다. 첫 번째 인자는 체인 함수의 특성을 가진 다양한 함수를 만들어내기 위해서 설정하는 함수를 넣으며 세팅하는 함수에 따라 다양한 특성의 체인 함수가 만들어진다. 이런 체인 함수를 만들기 위해서 첫 번째 함수는 모나드 연산이 가능한 함수가 위치해야 한다. 모나드 연산이 가능하다는 것은 함수의 입력과 출력이 모나드 연산을 하기 위한 연산자들에 대해 수학적으로 닫혀있는 상태이며 수학적으로 닫혀 있는 값들이 존재하는 이데아적인 공간인 어떤 공역의 부분집합의 값이 함수의 입력과 출력이 된다는 의미이다.
- `chain(f, g)(x)`가 `f(g(x), x)`와 동등하다는 것은 `g(x)`의 결과는 `x`라는 리스트에 포함될 수 있는 값이어야 한다는 것을 의미한다. 곧 부분집합에 해당하는 것이다. 수식으로 보면 `f(g([x1, x2, x3 ...]), [x1, x2, x3 ...])`으로 `g([x1, x2, x3 ...])`의 값이 `[x1, x2, x3 ...]`에 포함될 수 있는 값이라는 것이고 이것은 `g([x1, x2, x3 ...])`와 `[x1, x2, x3 ...]`가 동일한 타입의 모나드에 해당한다는 것을 의미한다. 뒤에 나오는 표현식 `(a → m b)`의 `m b`와 `chain`함수의 최종 평가값 `m b`는 동일한 유형의 모나드이지만 값이 다를 수 있는 이유이기도 하다.
- `chain(f, g)(x)`가 `f(g(x), x)`와 동등하다는 것은 `g(x)`의 결과는 `x`라는 리스트에 포함될 수 있는 값이어야 한다는 것을 의미한다. 곧 부분집합에 해당하는 것이다. 리스트의 경우는 `f(g([x1, x2, x3 ...]), [x1, x2, x3 ...])`으로 `g([x1, x2, x3 ...])`의 값이 `[x1, x2, x3 ...]`에 포함될 수 있는 값이라는 것이고 이것은 `g([x1, x2, x3 ...])`와 `[x1, x2, x3 ...]`가 동일한 타입의 모나드에 해당한다는 것을 의미한다. 뒤에 나오는 표현식 `(a → m b)`의 `m b`와 `chain`함수의 최종 평가값 `m b`는 동일한 유형의 모나드이지만 값이 다를 수 있는 이유이기도 하다.
- 두 번째 인자가 함수가 아닌 리스트가 오는 경우는 체인한 함수가 반환한 함수(`chain(f, g)`)에 리스트를 할당(`chain(f, g)(list)`)하는 것이 아니라 `chain(h, list)`의 표현식에 해당한다. 따라서 내부적으로 처리하는 방식이 조금 다르지만 큰 틀에서의 개념은 비슷하다. 첫 번째 인자로 `f`와 `g`와 다른 `h`로 표현했는데 연산 방식이 `flatten(map(h, list))`이기 때문이다. 이를 `f(g(x), x)` 표현식으로 변경을 해 보면, `flatten(map(h, list), list)`와 동일하다. `flatten`함수는 인자를 배열 하나만 받기 때문에 두 번째 인자는 무시된다. 이는 `f`에 해당하는 `flatten` 함수의 두 번째 인자로는 어떤 타입이든 가정하고 집어 넣어도 괜찮다는 의미이다. `g(x)`에 해당하는 `map(h, list)`는 리스트를 반환하고 `f`의 두 번째 인자가 리스트이므로 이는 일치하는 모나드 유형을 갖는다는 것을 알 수 있다. 자바스크립트의 리스트는 자주 사용되는 모나드 유형이므로 예외적으로 `chain` 함수는 두 번째 인자로 함수를 받는 방식 이외의 리스트를 사용할 때는 좀 더 간결한 방식으로 사용할 수 있도록 만든 것으로 보인다.
- 어떤 모나드 유형의 값이 존재하고 해당 모나드의 부분집합에 해당하는 모나드를 만드는 함수(`g`)를 정의한 뒤 모나드와 모나드의 부분집합의 연산(`f`)을 하기 위한 함수라고 보면된다. `g`는 부분집합을 만드는 함수이고 `f`는 부분집합과 원본간의 연산을 위한 함수이다.

## 표현
```
Chain m => (a → m b) → m a → m b
```
- `Chain m => ` 여기서 `m`은 모나드를 의미한다. `m b`는 `b`는 모나드로서 활용되는 값이라는 것이며, `m a`는 `a`는 모나드로서 활용되는 값이라는 의미이다.
- 자바스크립트와 `RamdaJS`에서 사용되는 모나드의 형태는 리스트의 형태이므로 일반적으로 연관 배열이 아닌 값이 나열된 배열을 받지만, 사양상 모나드 형식을 만족하는 어떤 대상이라도 올 수 있지만 리스트와 함수로 제한되어 쓰이는 것으로 보인다. 자바스크립트에서는 리스트 뿐만이 아니라 순수함수의 합성을 가능하게 하는 함수도 모나드이다. 만약 주어진 값이 리스트 형식이라면 `m a`와 `m b`도 모나드 연산을 이룰 수 있어야 하므로 리스트 형식이어야 하며, 만약 주어진 값이 함수라면 `m a`와 `m b`도 함수의 합성 연산을 할 수 있는 모나드인 함수의 형태여야 한다.
- `(a → m b)`는 첫 번째 인자로 인자를 하나 받아 어떤 모나드 값을 반환하는 함수를 받는다는 의미이다.
- `→ m a →` 두 번째 인자로도 모나드를 받는다. 이 때, 리스트를 받는 경우와 함수를 받는 경우를 생각해 볼 수 있다.
- `→ m b` 부분을 보자. 두 번째 인자로 `m a`로 리스트를 받게 되면 `(a → m b)`에 의해 반환 되는 대상도 리스트에 해당한다. 그러나 두 번째 인자로 함수를 받게 되면 반환 되는 대상도 함수를 반환하게 된다.
- 최종적으로 함수를 반환했을 때는 함수 자체로는 결과값을 얻는데 이용하지 않으므로 해당 함수를 평가하기 위해서 반환된 함수 `m b`는 추가적으로 인자를 받아 함수를 평가하도록 한다.

## 예제
```
const duplicate = n => [n, n];
R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
```
- `R.chain(duplicate, [1, 2, 3])`는 첫 번째 인자로 함수, 두 번째 인자로 리스트를 받았다. 이 경우 `chain` 함수는 `map`함수의 방식으로 `duplicate` 함수에 리스트의 각 원소를 전달하여 실행한 결과를 `duplicate(1)`, `duplicate(2)`, `duplicate(3)`으로 가지며 이 결과는 `[1,1]`, `[2,2]`, `[3,3]`이 된다. `chain`은 각각의 결과를 연결하고 배열의 중첩을 제거한 결과를 반환하므로 `[1, 1, 2, 2, 3, 3]`을 반환하게 된다.

```
R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
```
- `R.chain(R.append, R.head)([1, 2, 3])`는 첫 번째 인자로 함수, 두 번째 인자로도 함수를 받았다. 두 번째 인자로 리스트를 받았을 경우에는 첫 번째 인자로 받은 함수에 리스트의 각 원소를 할당했으나 함수는 리스트가 아니므로 원소를 갖지 못한다. 그래서 두 번째 함수를 첫 번째 함수의 인자에 그대로 전달한다. 첫 번째 함수를 f, 두 번째 함수를 g, 두 번째 인자가 함수가 아닌 리스트의 경우 리스트의 원소를 `Xn(x1, x2, x3 ...)`라고 했을 때, 두 번째 인자가 리스트의 경우는 `f(x1)`, `f(x2)`, `f(x3)`를 연결한 결과가 되었던 반면, 두 번째 인자가 함수인 경우는 `f(g(x), x)`의 원칙에 따라 `R.append(R.head(x), x)`가 된다. 이 반환된 함수에 리스트 인자를 할당하여 `R.append(R.head(x), x)([1,2,3])`이 되므로 `R.append(R.head([1,2,3]), [1,2,3])`가 된다. 따라서 결과 값은 주어진 리스트에서 첫 번째 원소를 뽑는 `R.head([1,2,3])`에 의해 `1`을 반환, `R.append(1, [1,2,3])`에 따라 `[1,2,3,4]`를 반환한다.

## Reference
- https://ramdajs.com/docs/#chain
- https://github.com/fantasyland/fantasy-land#chain
- https://stackoverflow.com/questions/45786580/ramda-chain-usage

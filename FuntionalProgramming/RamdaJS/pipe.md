## pipe

### 설명
> Performs left-to-right function composition. The first argument may have any arity; the remaining arguments must be unary.
- 왼쪽에서 오른쪽으로 함수의 합성을 수행한다. 첫 번째 인자로 받는 함수는 임의의 인자 수를 가질 수 있지만, 나머지 인자로 받는 함수는 반드시 단항의 인자를 받는 함수여야 한다.

> In some libraries this function is named sequence.
- 일부 라이브러리에서 pipe란 함수는 sequence라고 부르기도 한다.

> Note: The result of pipe is not automatically curried.
- pipe 함수의 결과는 자동적으로 커링되지 않는다.

> See also compose.

### 설명
- 인자에 함수를 나열하여 반환된 결과 함수를 평가할 때 인자로 나열한 첫 번째 함수부터 차례대로 실행하고 각 함수의 실행 결과를 다음에 실행할 함수의 인자로 전달한다.
- pipe(f,g,h)라고 하면 f(x), g(f(x)), h(g(f(x)))의 형태로 실행을 한다. 이는 일반적으로 수학에서 배우는 함수의 합성과 같다. h◦g◦f이다. 함수의 합성 순서와 함수의 실행 순서는 반대가 되는 점에 유의하자.
- 합성할 함수 리스트는 나눠서 받을 수 없으며 한 번에 인자로 할당되어야 한다. 이는 언젠가는 인자를 받아서 평가되는 함수가 되어야 하는데, 합성할 함수만을 계속 받다보면 함성된 함수를 반환할 때를 지정하기 어려운 점이 있기 때문에 합성할 인자를 커링을 통해서 계속 받기 보다는 한 번에 합성할 인자를 모두 받아 합성된 함수를 반환하도록 설계 되었다.
- pipe로 함수를 합성한 결과 함수는 자동적으로 커링되지 않는다. pipe 함수의 첫 번째 인자로 커링된 함수를 전달했다면 합성된 결과 함수도 커링되지만, 커링되지 않은 함수를 합성한 함수의 결과 함수가 자동적으로 커링되지는 않는다. 

### 표현
```
(((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) → ((a, b, …, n) → z)
```
- `(((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) →`: 첫 번째 함수의 인자로 함수 리스트를 받는다. 이때 전달 받는 함수 리스트의 첫 번재 함수는 `((a, b, …, n) → o)`으로 받을 수 있는 인자의 갯수에 제한이 없으나, `(x → y)`, `(y → z)`등 함수 리스트의 나머지 함수는 반드시 하나의 인자를 받는 함수라는 것을 알 수 있다. 이는 이전 함수가 평가된 결과값을 받아 실행하는 형식으로 구성되어 있기 때문이다. 특이한 점은, pipe 함수는 합성할 인자를 인자를 나눠서 받지 않고, 한 번에 받는다는 것이다.
- `→ ((a, b, …, n) → z)`: 합성된 함수로 합성할 함수 리스트의 첫 번째 함수가 받는 인자와 구성이 동일하다는 것을 알 수 있다.

### 예제
```js
const f = R.pipe(Math.pow, R.negate, R.inc);

f(3, 4); // -(3^4) + 1
```
- `Math.pow` 첫 번째 인자를 밑으로 두 번째 인자를 지수로 하는 거듭제곱을 계산하는 함수이다.
- `R.negate` 수로 된 인자를 음수로 바꾸는 함수이다.
- `R.inc` 수로 된 인자의 값을 1증가시킨다.
- 왼쪽 부터 계산을 하게 되면, `Math.pow`에 의해 (3^4), `R.negate`에 의해 -(3^4), `R.inc`에 의해 1가 된다.
- 만약 오른쪽 부터 계산하게 되면, 3, 4 두개의 인자가 주어지지만 `R.inc`는 하나의 인자만 받으므로 나머지 하나의 인자의 정보가 소실된다.

### Reference
- https://ramdajs.com/docs/#pipe

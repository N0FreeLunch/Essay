## applySpec
- R.applySpec

## 표현
```
{k: ((a, b, …, m) → v)} → ((a, b, …, m) → {k: v})
```
- `{k: ((a, b, …, m) → v)}` 리터럴 오브젝트를 의미한다. 리터럴 오브젝트의 키를 `k`, 리터럴 오브젝트의 벨류는 `((a, b, …, m) → v)`이다.
- `((a, b, …, m) → v)`는 리터럴 오브젝트의 벨류 값은 함수를 지정하는데 이 함수는 인자로 여러 인자를 받고 다양한 타입의 인자를 받을 수 있다는 것을 의미
- applySpec에 리터럴 오브젝트를 넣고 반환 된 값은 `((a, b, …, m) → {k: v})` 형식의 함수를 반환하는 것.
- 타입은 첫 번째 인자의 리터럴 오브젝트의 벨류가 되는 함수의 인자와 동일한 타입의 인자를 넣어 줘야 하기 때문에 `(a, b, …, m)`가 된다.
- `(a, b, …, m)` 값을 넣어 주면 `→ {k: v}`라는 리터럴 오브젝트 형식의 값이 나오고 `v`는 첫 번째 인자의 `((a, b, …, m) → v)` 부분에 따라 `(a, b, …, m)` 타입에 해당하는 값을 받았을 때 평가되는 결과 값 `v`를 반환되는 리터럴 오브젝트의 벨류 값으로 함

## 설명
- 첫 번째 인자로는 특정 형식의 리터럴 오브젝트를 받는다.
- 리터럴 오브젝트의 형식은 키-'인자를 받아 평가되는 함수' 또는 "키-'인자를 받아 평가되는 함수'"가 들어 있는 리터럴 오브젝트를 벨류로 해야 한다. (이를 재귀 형식의 객체라고 부른다.)
- 두 번째 인자의 갯수는 첫 번째 인자의 '인자를 받아 평가되는 함수'에 들어가는 인자의 갯수와 순서 타입이 같아야 한다.
- 두 번째 인자를 첫 번째 인자의 리터럴 오브젝트 내의 '인자를 받아 평가되는 함수'에 인자로 할당하고 그 평가된 값을 첫 번째 인자의 리터럴 오브젝트 형식과 일치하게 하면서 '인자를 받아 평가되는 함수' 위치에 평가된 값을 넣은 결과를 반환한다.

## 예제
```
const getMetrics = R.applySpec({
  sum: R.add,
  nested: { mul: R.multiply }
});
getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
```
- `R.applySpec` 함수는 인자로 리터럴 오브젝트를 받았다.
```
{
  sum: R.add,
  nested: { mul: R.multiply }
}
```
- 첫 번째 인자의 리터럴 오브젝트는 '키-벨류' 형식에서 벨류값이 인자를 받아 평가를 기다리는 함수 또는 이런 함수가 들어가 있는 리터럴 오브젝트로 되어 있다.
- 두 번째 인자부터 받은 인자는 순차적으로 리터럴 오브젝트 내부의 '인자를 받아 평가를 기다리는 함수'의 인자로 들어가서 리터럴 오브젝트 내부의 함수는 평가된다.
- 첫 번째 인자에 지정한 리터럴 오브젝트의 구조에 따라서 결과 값을 반환한다. 이 때, 리터럴 오브젝트 내의 '인자를 받아 평가를 기다리는 함수'가 함수가 평가되어 결과 값으로 바뀐 형태의 동일 형태의 리터럴 오브젝트를 반환 받는다.

## Reference
- https://ramdajs.com/docs/#applySpec
